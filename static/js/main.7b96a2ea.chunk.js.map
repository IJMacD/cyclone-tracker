{"version":3,"sources":["use-dimensions.js","Map.jsx","App.js","serviceWorker.js","index.js"],"names":["useDimensions","useState","dimensions","setDimensions","ref","useRef","useLayoutEffect","current","measure","window","requestAnimationFrame","node","rect","getBoundingClientRect","width","height","top","x","left","y","right","bottom","getDimensionObject","addEventListener","removeEventListener","LAT","LON","SCALE","INITIAL_WIDTH","INITIAL_HEIGHT","CLOUD_FACTOR","SATELLITE_LISTING","SATELLITE_IMAGE","SATELLITE_BOUNDS","minLon","minLat","maxLon","maxLat","ONE_HOUR","COLOURS","TD","TS","STS","T","ST","SST","LOW","Map","myLocation","cyclones","showSatellite","time","bgRef","React","satRef","dpr","devicePixelRatio","pixelWidth","pixelHeight","dLon","dLat","bounds","coastline","setCoastline","satelliteList","setSatelliteList","useEffect","a","fetch","d","text","t","lines","split","map","l","trim","filter","length","dates","Date","setUTCFullYear","substr","setUTCMonth","setUTCDate","setUTCHours","setUTCMinutes","setUTCSeconds","setUTCMilliseconds","fetchList","selectedImage","now","setMinutes","Math","floor","getMinutes","setSeconds","setTime","ctx","getContext","satUrl","replace","match","key","getUTCFullYear","toString","getFullYear","getMonth","padStart","getUTCMonth","getDate","getUTCDate","getHours","getUTCHours","minutes","now_start","img","Image","src","onload","getPosition","longitude","latitude","x1","y1","x2","y2","drawImage","clearRect","beginPath","r","ellipse","PI","fillStyle","fill","cyclone","findCurrent","windspeed","grad","createRadialGradient","addColorStop","globalAlpha","segments","breakIntoSegments","i","segment","next_segment","segment_p1","next_segment_p1","curr_colour","classification","next_colour","colour","x0","y0","createLinearGradient","thickness","dash","type","setLineDash","strokeLine","track","point","strokeStyle","font","n","name","nameZH","strokeText","fillText","substring","s","fetchCoastline","features","feature","geometry","coordinates","p","coords","style","position","zIndex","points","lineWidth","first","moveTo","lineTo","stroke","prev","find","currentSet","push","console","warn","App","props","state","realTime","navigator","geolocation","getCurrentPosition","setState","this","timeout","setInterval","fetchData","bind","realtimer","clearInterval","json","className","c","id","distance","bearing","checked","onChange","e","target","onClick","Component","Boolean","location","hostname","ReactDOM","render","document","getElementById","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.7b96a2ea.chunk.js","sourcesContent":["import { useState, useRef, useLayoutEffect } from \"react\";\r\n\r\n/** \r\n * @typedef DimensionObject\r\n * @prop {number} [width]\r\n * @prop {number} [height]\r\n * @prop {number} [top]\r\n * @prop {number} [left]\r\n * @prop {number} [right]\r\n * @prop {number} [bottom]\r\n * @prop {number} [x]\r\n * @prop {number} [y]\r\n */\r\n\r\nfunction getDimensionObject (node) {\r\n    const rect = node.getBoundingClientRect();\r\n\r\n    return {\r\n        width: rect.width,\r\n        height: rect.height,\r\n        top: \"x\" in rect ? rect.x : rect.top,\r\n        left: \"y\" in rect ? rect.y : rect.left,\r\n        x: \"x\" in rect ? rect.x : rect.left,\r\n        y: \"y\" in rect ? rect.y : rect.top,\r\n        right: rect.right,\r\n        bottom: rect.bottom\r\n    };\r\n}\r\n\r\n/**\r\n *  @return {[React.MutableRefObject, DimensionObject]}\r\n */\r\nfunction useDimensions() {\r\n    const [dimensions, setDimensions] = useState({});\r\n    const ref = useRef();\r\n\r\n    useLayoutEffect(() => {\r\n        if (ref.current) {\r\n            const measure = () =>\r\n                window.requestAnimationFrame(() =>\r\n                    setDimensions(getDimensionObject(ref.current))\r\n                );\r\n            measure();\r\n\r\n            window.addEventListener(\"resize\", measure);\r\n\r\n            return () => {\r\n                window.removeEventListener(\"resize\", measure);\r\n            };\r\n        }\r\n    }, [ref]);\r\n\r\n    return [ref, dimensions];\r\n}\r\n\r\nexport default useDimensions;","import React from 'react';\r\nimport useDimensions from './use-dimensions';\r\n\r\n// COORDS of HKO\r\nconst LAT = 22.3025;\r\nconst LON = 114.174167;\r\nconst SCALE = 0.033;\r\nconst INITIAL_WIDTH = 1000;\r\nconst INITIAL_HEIGHT = 1000;\r\n\r\nconst CLOUD_FACTOR = 2.0;\r\n\r\nconst SATELLITE_LISTING = \"https://maps.weather.gov.hk/gis-portal/web/data/dirList/satellite_IR_group.txt\";\r\nconst SATELLITE_IMAGE = \"https://maps.weather.gov.hk/gis-portal/web/data/%{year_utc}%{month_utc}%{day_utc}/satellite/IR1-L1B-10/%{hour_utc}%{minute}/%{year}%{month}%{day}%{hour}%{minute}+%{day_start}%{hour_start_utc}%{minute_start}H08.10S_50N_75_150E--L1B.H08_IR1_10_no_coast.png\";\r\nconst SATELLITE_BOUNDS = {\r\n    minLon: 75,\r\n    minLat: -10,\r\n    maxLon: 150,\r\n    maxLat: 56,\r\n};\r\n\r\nconst ONE_HOUR = 60 * 60 * 1000;\r\n\r\nconst COLOURS = {\r\n    TD: \"#303030\",\r\n    TS: \"#28911A\",\r\n    STS: \"#273AC1\",\r\n    T:  \"#DD4343\",\r\n    ST: \"#F78BC0\",\r\n    SST: \"#F78BC0\",\r\n    LOW: \"#8FE1ED\",\r\n};\r\n\r\n/**\r\n * @typedef Cyclone\r\n * @prop {number} id \r\n * @prop {string} name \r\n * @prop {string} nameZH\r\n * @prop {string} bearing\r\n * @prop {number} distance\r\n * @prop {Point[]} track\r\n */\r\n\r\n/**\r\n * @typedef Point\r\n * @prop {\"P\"|\"A\"|\"F\"} type \r\n * @prop {string} time \r\n * @prop {number} latitude \r\n * @prop {number} longitude \r\n * @prop {string} [classification]\r\n * @prop {number} [windspeed]\r\n */\r\n\r\n/**\r\n * @param {{ myLocation, cyclones: Cyclone[], showSatellite: boolean, time?: number }} param0\r\n */\r\nexport default function Map ({ myLocation, cyclones, showSatellite, time }) {\r\n    /** @type {React.MutableRefObject<HTMLCanvasElement} */\r\n    const bgRef = React.useRef();\r\n    /** @type {React.MutableRefObject<HTMLCanvasElement} */\r\n    const satRef = React.useRef();\r\n    \r\n    /** @type {[React.MutableRefObject<HTMLCanvasElement>, { width?: number, height?: number }]} */\r\n    const [ ref, { width = INITIAL_WIDTH, height = INITIAL_HEIGHT} ] = useDimensions();\r\n\r\n    const dpr = devicePixelRatio;\r\n    const pixelWidth = dpr * width;\r\n    const pixelHeight = dpr * height;\r\n\r\n    const dLon = SCALE * pixelWidth / 2;\r\n    const dLat = SCALE * pixelHeight / 2;\r\n\r\n    const bounds = {\r\n        minLat: LAT - dLat,\r\n        minLon: LON - dLon,\r\n        maxLat: LAT + dLat,\r\n        maxLon: LON + dLon,\r\n        width: pixelWidth,\r\n        height: pixelHeight,\r\n    };\r\n\r\n    const [ coastline, setCoastline ] = React.useState();\r\n    const [ satelliteList, setSatelliteList ] = React.useState();\r\n\r\n    // Satellite Listing\r\n    React.useEffect(() => {\r\n        async function fetchList () {\r\n            const d = await fetch(SATELLITE_LISTING);\r\n            const t = await d.text();\r\n            const lines = textToLines(t);\r\n\r\n            const dates = lines.map(l => {\r\n                const d = new Date();\r\n                d.setUTCFullYear(l.substr(0,4));\r\n                d.setUTCMonth(l.substr(4,2) - 1);\r\n                d.setUTCDate(l.substr(6,2));\r\n                d.setUTCHours(l.substr(9,2));\r\n                d.setUTCMinutes(l.substr(1,2));\r\n                d.setUTCSeconds(0);\r\n                d.setUTCMilliseconds(0);\r\n                return d;\r\n            });\r\n            setSatelliteList(dates);\r\n        }\r\n\r\n        fetchList();\r\n    }, []);\r\n\r\n    // Satellite Image\r\n    React.useEffect(() => {\r\n        if (satRef.current) {\r\n            const selectedImage = new Date(time || Date.now());\r\n            selectedImage.setMinutes(Math.floor(selectedImage.getMinutes() / 10) * 10);\r\n            selectedImage.setSeconds(0);\r\n            selectedImage.setTime(+selectedImage - ONE_HOUR);\r\n                \r\n            const ctx = satRef.current.getContext(\"2d\");\r\n\r\n            if (showSatellite) {\r\n                const satUrl = SATELLITE_IMAGE.replace(/%{([a-z_]+)}/g, (match, key) => {\r\n                    if (key === \"year\") return selectedImage.getUTCFullYear().toString();\r\n                    if (key === \"year_utc\") return selectedImage.getFullYear().toString();\r\n                    if (key === \"month\") return (selectedImage.getMonth()+1).toString().padStart(2, \"0\");\r\n                    if (key === \"month_utc\") return (selectedImage.getUTCMonth()+1).toString().padStart(2, \"0\");\r\n                    if (key === \"day\") return selectedImage.getDate().toString().padStart(2, \"0\");\r\n                    if (key === \"day_utc\") return selectedImage.getUTCDate().toString().padStart(2, \"0\");\r\n                    if (key === \"hour\") return selectedImage.getHours().toString().padStart(2, \"0\");\r\n                    if (key === \"hour_utc\") return selectedImage.getUTCHours().toString().padStart(2, \"0\");\r\n                    const minutes = Math.floor(selectedImage.getMinutes() / 10) * 10;\r\n                    if (key === \"minute\") return minutes.toString().padStart(2, \"0\");\r\n\r\n                    const now_start = new Date(+selectedImage - 10 * 60 * 1000);\r\n                    if (key === \"day_start\") {\r\n                        return now_start.getUTCDate().toString().padStart(2, \"0\");\r\n                    }\r\n                    if (key === \"hour_start_utc\") {\r\n                        return now_start.getUTCHours().toString().padStart(2, \"0\");\r\n                    }\r\n                    if (key === \"minute_start\") {\r\n                        const minute_start = Math.floor(now_start.getMinutes() / 10) * 10;\r\n                        return minute_start.toString().padStart(2, \"0\");\r\n                    }\r\n\r\n                    return match;\r\n                });\r\n\r\n                const img = new Image(800, 724);\r\n                img.src = satUrl;\r\n                img.onload = () => {\r\n                    const { x: x1, y: y1 } = getPosition({ longitude: SATELLITE_BOUNDS.minLon, latitude: SATELLITE_BOUNDS.maxLat }, bounds);\r\n                    const { x: x2, y: y2 } = getPosition({ longitude: SATELLITE_BOUNDS.maxLon, latitude: SATELLITE_BOUNDS.minLat }, bounds);\r\n                    ctx.drawImage(img, x1, y1, x2 - x1, y2 - y1);\r\n                }\r\n            } else {\r\n                ctx.clearRect(0, 0, bounds.width, bounds.height);\r\n            }\r\n        }\r\n    }, [satelliteList, bounds, satRef, showSatellite, time]);\r\n\r\n    // Cyclone Track\r\n    React.useEffect(() => {\r\n        if (ref.current) {\r\n            const ctx = ref.current.getContext(\"2d\");\r\n\r\n            ctx.clearRect(0, 0, bounds.width, bounds.height);\r\n\r\n            if (myLocation) {\r\n                const { x, y } = getPosition(myLocation, bounds);\r\n                ctx.beginPath();\r\n                const r = dpr * 2.0;\r\n                ctx.ellipse(x, y, r, r, 0, 0, Math.PI * 2);\r\n                ctx.fillStyle = \"#FF0000\";\r\n                ctx.fill();\r\n            }\r\n\r\n            for (const cyclone of cyclones) {\r\n                const current = findCurrent(cyclone, time);\r\n\r\n                if (!showSatellite && current && current.windspeed) {\r\n                    const { x, y } = getPosition(current, bounds);\r\n                    ctx.beginPath();\r\n                    const r = current.windspeed * CLOUD_FACTOR * dpr;\r\n                    ctx.ellipse(x, y, r, r, 0, 0, Math.PI * 2);\r\n                    const grad = ctx.createRadialGradient(x, y, 10 * dpr, x, y, r);\r\n                    grad.addColorStop(0, \"#C0C0C0\");\r\n                    grad.addColorStop(0.9, \"#C0C0C0\");\r\n                    grad.addColorStop(1, \"#FFFFFF\");\r\n                    ctx.fillStyle = grad;\r\n                    ctx.globalAlpha = 0.5;\r\n                    ctx.fill();\r\n                    ctx.globalAlpha = 1;\r\n                    // ctx.strokeStyle = \"#FF0000\";\r\n                    // ctx.lineWidth = 1 * dpr;\r\n                    // ctx.stroke();\r\n\r\n                }\r\n\r\n                const segments = breakIntoSegments(cyclone);\r\n\r\n                for (let i = 1; i < segments.length; i++) {\r\n                    const segment = segments[i-1];\r\n                    const next_segment = segments[i];\r\n\r\n                    const segment_p1 = segment[0];\r\n                    const next_segment_p1 = next_segment[0];\r\n\r\n                    const curr_colour = COLOURS[segment_p1.classification];\r\n                    const next_colour = COLOURS[next_segment_p1.classification];\r\n                    \r\n                    let colour = curr_colour;\r\n                    if (curr_colour !== next_colour) {\r\n                        const { x: x0, y: y0 } = getPosition(segment_p1, bounds);\r\n                        const { x: x1, y: y1 } = getPosition(next_segment_p1, bounds);\r\n                        colour = ctx.createLinearGradient(x0, y0, x1, y1);\r\n                        colour.addColorStop(0, curr_colour);\r\n                        colour.addColorStop(1, next_colour);\r\n                    }\r\n\r\n                    const thickness = 4 * dpr;\r\n                    \r\n                    const dash = (next_segment_p1.type === \"P\") ? [] : [thickness * 2, thickness * 2];\r\n                    ctx.setLineDash(dash);\r\n                    \r\n                    strokeLine(ctx, bounds, [ ...segment, next_segment_p1 ], colour, thickness);\r\n\r\n                    ctx.setLineDash([]);\r\n                }\r\n\r\n                const currentColour = \"#800080\";\r\n\r\n                for (const point of cyclone.track) {\r\n                    if (point.windspeed && point.classification || point === current) {\r\n                        ctx.beginPath();\r\n                        const { x, y } = getPosition(point, bounds);\r\n                        const r = (point.windspeed || 50) * 0.1 * dpr;\r\n                        ctx.ellipse(x, y, r, r, 0, 0, Math.PI * 2);\r\n                        ctx.fillStyle = (point === current) ? currentColour : COLOURS[point.classification];\r\n                        ctx.fill();\r\n                    }\r\n                }\r\n\r\n                if (current) {\r\n                    const { x, y } = getPosition(current, bounds);\r\n                    ctx.strokeStyle = \"#FFFFFF\";\r\n                    ctx.fillStyle = currentColour;\r\n                    ctx.font = `${Math.floor(12 * dpr)}px sans-serif`;\r\n                    const n = `${cyclone.name} ${cyclone.nameZH}`;\r\n                    ctx.strokeText(n, x, y + 18 * dpr);\r\n                    ctx.fillText(n, x, y + 18 * dpr);\r\n                    const d = current.time.substring(0, 13);\r\n                    ctx.strokeText(d, x, y + 30 * dpr);\r\n                    ctx.fillText(d, x, y + 30 * dpr);\r\n                    if (current.windspeed) {\r\n                        const s = `${current.windspeed} km/h`;\r\n                        ctx.strokeText(s, x, y + 42 * dpr);\r\n                        ctx.fillText(s, x, y + 42 * dpr);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }, [myLocation, cyclones, bounds, ref, time, dpr]);\r\n\r\n    // Load coastline\r\n    React.useEffect(() => {\r\n        async function fetchCoastline () {\r\n            const coastline = await import(\"./coastline.json\");\r\n            setCoastline(coastline);\r\n        }\r\n        fetchCoastline();\r\n    }, []);\r\n\r\n    // Draw Coastline\r\n    React.useEffect(() => {\r\n        if (bgRef.current && coastline) {\r\n            const ctx = bgRef.current.getContext(\"2d\");\r\n\r\n            ctx.clearRect(0, 0, bounds.width, bounds.height);\r\n\r\n            for (const feature of coastline.features) {\r\n                if (feature.geometry.type === \"LineString\") {\r\n                    strokeLine(ctx, bounds, feature.geometry.coordinates.map(p => ({ latitude: p[1], longitude: p[0] })), \"#80C080\", 1);\r\n                }\r\n                else if (feature.geometry.type === \"MultiLineString\"){\r\n                    for (const coords of feature.geometry.coordinates) {\r\n                        strokeLine(ctx, bounds, coords.map(p => ({ latitude: p[1], longitude: p[0] })), \"#80C080\", 1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }, [coastline, bounds]);\r\n\r\n    return <div style={{ position: \"relative\" }}>\r\n        <canvas ref={satRef} width={bounds.width} height={bounds.height} style={{ width: \"100vw\", height: \"100vh\", position: \"absolute\", zIndex: -2 }} />\r\n        <canvas ref={bgRef} width={bounds.width} height={bounds.height} style={{ width: \"100vw\", height: \"100vh\", position: \"absolute\", zIndex: -1 }} />\r\n        <canvas ref={ref} width={bounds.width} height={bounds.height} style={{ width: \"100vw\", height: \"100vh\" }} />\r\n    </div>;\r\n}\r\n\r\n/**\r\n * @param {string} text\r\n */\r\nfunction textToLines (text) {\r\n    return text.split(\"\\n\").map(l => l.trim()).filter(l => l.length > 0);\r\n}\r\n\r\n/**\r\n * @param {{ latitude: number, longitude: number }} point\r\n */\r\nfunction getPosition (point, bounds) {\r\n    const x = (point.longitude - bounds.minLon) / (bounds.maxLon - bounds.minLon) * bounds.width;\r\n    const y = bounds.height - (point.latitude - bounds.minLat) / (bounds.maxLat - bounds.minLat) * bounds.height;\r\n\r\n    return { x, y };\r\n}\r\n\r\nfunction strokeLine(ctx, bounds, points, colour=\"#000000\", lineWidth=1) {\r\n    ctx.strokeStyle = colour;\r\n    ctx.lineWidth = lineWidth;\r\n    ctx.beginPath();\r\n                \r\n    let first = true;\r\n    for (const point of points) {\r\n        const { x, y } = getPosition(point, bounds);\r\n        first ? ctx.moveTo(x, y) : ctx.lineTo(x, y);\r\n        first = false;\r\n    }\r\n    ctx.stroke();\r\n}\r\n\r\nconst DIRECTIONS = \"N NNE NE ENE E ESE SE SSE S SSW SW WSW W WNW NW NNW\".split(\" \");\r\nfunction compassToRadians (direction) {\r\n    return DIRECTIONS.indexOf(direction) * Math.PI * 2 / DIRECTIONS.length;\r\n}\r\n\r\n/**\r\n * \r\n * @param {Cyclone} cyclone\r\n * @param {number} [time] \r\n */\r\nfunction findCurrent (cyclone, time) {\r\n    let prev = null;\r\n    if (time) {\r\n        for (const point of cyclone.track) {\r\n            if (+new Date(point.time) > time) return prev;\r\n            prev = point;\r\n        }\r\n    }\r\n    return cyclone.track.find(p => p.type === \"A\")\r\n}\r\n\r\n/**\r\n * \r\n * @param {Cyclone} cyclone\r\n */\r\nfunction breakIntoSegments (cyclone) {\r\n    const segments = [];\r\n    let currentSet = null;\r\n\r\n    for (const point of cyclone.track) {\r\n        if (point.classification) {\r\n            if (currentSet) {\r\n                segments.push(currentSet);\r\n            }\r\n\r\n            currentSet = [point];\r\n        } else {\r\n            if (!currentSet) {\r\n                console.warn(\"Expected a point with classification\");\r\n                currentSet = [];\r\n            }\r\n            currentSet.push(point);\r\n        }\r\n    }\r\n\r\n    if (currentSet) {\r\n        segments.push(currentSet);\r\n    }\r\n\r\n    return segments\r\n}\r\n\r\n/**\r\n * \r\n * @param {Date[]} dates \r\n * @param {number} time\r\n * @returns {Date}\r\n */\r\nfunction mostRecent (dates, time) {\r\n    let prev = null;\r\n    for (const date of dates) {\r\n        if (time < +date) {\r\n            break;\r\n        }\r\n        prev = date;\r\n    }\r\n    return prev;\r\n}","import React from 'react';\r\nimport Map from './Map';\r\nimport './App.css';\r\n\r\nconst ONE_MINUTE = 60 * 1000;\r\nconst FIFTEEN_MINUTES = 15 * ONE_MINUTE;\r\nconst ONE_HOUR = 60 * ONE_MINUTE;\r\n\r\nclass App extends React.Component {\r\n  constructor (props) {\r\n    super(props);\r\n\r\n    this.state = {\r\n      cyclones: [],\r\n      myLocation: null,\r\n      showSatellite: false,\r\n      realTime: false,\r\n      time: Date.now(),\r\n    };\r\n  }\r\n\r\n  componentDidMount () {\r\n    navigator.geolocation.getCurrentPosition(({ coords: myLocation }) => {\r\n      this.setState({ myLocation });\r\n    });\r\n\r\n    this.timeout = setInterval(this.fetchData.bind(this), FIFTEEN_MINUTES);\r\n    this.realtimer = setInterval(() => this.state.realTime && this.setState({ time: Date.now() }), ONE_MINUTE);\r\n    this.fetchData();\r\n  }\r\n\r\n  componentWillUnmount () {\r\n    clearInterval(this.timeout);\r\n    clearInterval(this.realtimer);\r\n    this.timeout = null;\r\n  }\r\n\r\n  async fetchData () {\r\n    const r = await fetch(\"https://www.i-learner.edu.hk/weather/api/v2/cyclone\");\r\n    const cyclones = await r.json();\r\n\r\n    // Avoid updating state after unmount\r\n    if (this.timeout) {\r\n      this.setState({ cyclones });\r\n    }\r\n  }\r\n\r\n  render () {\r\n    return (\r\n      <div className=\"App\">\r\n        <Map\r\n          cyclones={this.state.cyclones}\r\n          myLocation={this.state.myLocation}\r\n          showSatellite={this.state.showSatellite}\r\n          time={this.state.realTime?this.state.time:0}\r\n        />\r\n        <ul className=\"App-key\">\r\n          {this.state.cyclones.map(c => <li key={c.id}>{c.name} {c.distance && `${c.distance} km`} {c.bearing}</li>)}\r\n          <li><label><input type=\"checkbox\" checked={this.state.showSatellite} onChange={e=>this.setState({ showSatellite: e.target.checked })} />Satellite</label></li>\r\n          <li>\r\n            <label><input type=\"checkbox\" checked={!this.state.realTime} onChange={e=>this.setState({ realTime: !e.target.checked })} />Latest</label>\r\n            {this.state.realTime && <div>\r\n              <button onClick={()=>this.setState({ time: this.state.time - ONE_HOUR })}>Earlier</button>\r\n              <button onClick={()=>this.setState({ time: this.state.time + ONE_HOUR })}>Later</button>\r\n            </div>}\r\n          </li>\r\n        </ul>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}